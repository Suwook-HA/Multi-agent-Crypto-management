"""Core data models and enumerations for the multi-agent crypto manager."""

from __future__ import annotations

from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum
from typing import Dict, List, Optional


class SentimentLabel(str, Enum):
    """Sentiment labels generated by the LLM driven sentiment agent."""

    POSITIVE = "positive"
    NEGATIVE = "negative"
    NEUTRAL = "neutral"


class TradeAction(str, Enum):
    """Actions that can be produced by the trading strategy agent."""

    BUY = "buy"
    SELL = "sell"
    HOLD = "hold"


@dataclass
class MarketTicker:
    """Represents a market ticker snapshot from Bithumb."""

    symbol: str
    price: float
    change_24h: float
    volume_24h: float
    base_currency: str = "KRW"
    high_24h: Optional[float] = None
    low_24h: Optional[float] = None
    timestamp: Optional[datetime] = None


@dataclass
class NewsArticle:
    """News article captured by the news discovery agent."""

    id: str
    title: str
    url: str
    summary: str
    published_at: datetime
    source: Optional[str] = None
    symbols: List[str] = field(default_factory=list)


@dataclass
class SentimentResult:
    """Sentiment assessment returned by the LLM."""

    article_id: str
    label: SentimentLabel
    score: float
    reasoning: str


@dataclass
class TradeDecision:
    """Decision generated by the strategy agent."""

    symbol: str
    action: TradeAction
    confidence: float
    price: float
    reasoning: str
    created_at: datetime = field(default_factory=lambda: datetime.now(timezone.utc))


@dataclass
class PortfolioPosition:
    """Represents an open position in a specific cryptocurrency."""

    symbol: str
    quantity: float
    average_price: float

    def update(self, quantity_delta: float, price: float) -> None:
        """Update the position after a trade."""

        if quantity_delta > 0:
            total_cost = self.average_price * self.quantity + price * quantity_delta
            self.quantity += quantity_delta
            if self.quantity:
                self.average_price = total_cost / self.quantity
        else:
            # Selling reduces quantity; keep average price constant
            self.quantity += quantity_delta
            if self.quantity < 0:
                self.quantity = 0


@dataclass
class TransactionRecord:
    """Record of a simulated trade executed by the portfolio agent."""

    symbol: str
    action: TradeAction
    quantity: float
    price: float
    timestamp: datetime
    reasoning: str


@dataclass
class PortfolioState:
    """Overall state of the simulated portfolio."""

    base_currency: str = "KRW"
    balances: Dict[str, float] = field(default_factory=lambda: {"KRW": 0.0})
    positions: Dict[str, PortfolioPosition] = field(default_factory=dict)
    history: List[TransactionRecord] = field(default_factory=list)

    def ensure_balance(self, currency: str) -> None:
        if currency not in self.balances:
            self.balances[currency] = 0.0

    def update_balance(self, currency: str, amount: float) -> None:
        self.ensure_balance(currency)
        self.balances[currency] += amount

    def get_position(self, symbol: str) -> PortfolioPosition:
        position = self.positions.get(symbol)
        if position is None:
            position = PortfolioPosition(symbol=symbol, quantity=0.0, average_price=0.0)
            self.positions[symbol] = position
        return position

    def record_transaction(self, transaction: TransactionRecord) -> None:
        self.history.append(transaction)

    def total_value(self, market_data: Dict[str, MarketTicker]) -> float:
        total = self.balances.get(self.base_currency, 0.0)
        for symbol, position in self.positions.items():
            ticker = market_data.get(symbol)
            if ticker and position.quantity > 0:
                total += position.quantity * ticker.price
        return total


@dataclass
class AgentState:
    """Shared state that agents collaborate on."""

    market_data: Dict[str, MarketTicker] = field(default_factory=dict)
    news: List[NewsArticle] = field(default_factory=list)
    sentiments: Dict[str, SentimentResult] = field(default_factory=dict)
    decisions: List[TradeDecision] = field(default_factory=list)
    portfolio: PortfolioState = field(default_factory=PortfolioState)
    metadata: Dict[str, str] = field(default_factory=dict)

    def add_news(self, articles: List[NewsArticle]) -> None:
        existing_ids = {article.id for article in self.news}
        for article in articles:
            if article.id not in existing_ids:
                self.news.append(article)
                existing_ids.add(article.id)

    def add_sentiment(self, sentiment: SentimentResult) -> None:
        self.sentiments[sentiment.article_id] = sentiment

    def add_decision(self, decision: TradeDecision) -> None:
        self.decisions.append(decision)

    def reset_decisions(self) -> None:
        self.decisions.clear()
